---
title: "Aboveground-Seascape Carbon"
output: html_notebook
---

Aboveground Cover
```{r}
#Libraries
library(ggplot2)
library(dplyr)
library(tidyverse)
library(plotrix)
library(dplyr)
```

```{r}
#set working directory
setwd("~/OneDrive - Old Dominion University/Ongoing Research/SG-Carbon.Ecotone/R.Data")
#Define Dataset
Aboveground<-(read.csv("AbCover.Clean.csv"))
```

#Subset Data
```{r}
#Seagrass
#Subset Data for just seagrass
SG.Cov<- subset(Aboveground, Aboveground$Type == "SG")
#Remove Labrador Park ("LP-1")
SG.Cov<-subset(SG.Cov, SG.Cov$Transect != "LP.1")
#Remove additional columns
SG.Cov1 <- SG.Cov %>% select(-MangCanCov, -Type, -Plot, -Transect)

#Mangrove- SB
#Subset Data for just Mangrove
MF.SB.Cov<- subset(Aboveground, Aboveground$Type == "MF")
#Remove All PU sites
MF.SB.Cov<-subset(MF.SB.Cov,Transect != "PU.1")
MF.SB.Cov<-subset(MF.SB.Cov,Transect != "PU.2")
MF.SB.Cov<-subset(MF.SB.Cov,Transect != "PU.3") 

#Remove additional columns
MF.SB.Cov1 <- MF.SB.Cov %>% select(-SeagrassCov, -Type, -Plot, -Transect)

#Mangrove-PU
#Subset Data for just Mangrove
MF.PU.Cov<- subset(Aboveground, Aboveground$Type == "MF")
#Remove All SB sites
MF.PU.Cov<-subset(MF.PU.Cov,Transect != "SB.1")
MF.PU.Cov<-subset(MF.PU.Cov,Transect != "SB.2")
MF.PU.Cov<-subset(MF.PU.Cov,Transect != "SB.3")
#Remove additional columns
MF.PU.Cov1 <- MF.PU.Cov %>% select(-SeagrassCov, -Type, -Plot, -Transect)

#Mangrove- All
#Subset Data for just Mangrove
MF.Cov<- subset(Aboveground, Aboveground$Type == "MF")
#Remove additional columns
MF.Cov1 <- MF.Cov %>% select(-SeagrassCov, -Type, -Plot, -Transect)

```

#Calculate Means
```{r}
#Seagrass
#Calculate Means and SE
SG.Cov2 <- SG.Cov %>% group_by(Plot.1) %>% 
summarise_each(funs(mean,sd,std.error))

#remove end points (neg end and pos end)
SG.Cov3<-subset(SG.Cov2, SG.Cov2$Plot.1 != "neg end")
SG.Cov3<-subset(SG.Cov3, SG.Cov3$Plot.1 != "pos end")

#Convert values to numeric
SG.Cov3$Plot <- as.numeric(SG.Cov3$Plot.1)

#keep just end points
SG.COV3ends <- SG.Cov2 %>%
  filter(Plot.1 %in% c("neg end", "pos end"))

#add point @ -10 and 10
SG.COV3ends$Plot.2 <- c(-10.5, 10.5)

#add new SE
SG.COV3ends$SE <- c(7.264832, 0)

#MF-SB
#Calculate Means and SE
MF.SB.Cov2 <- MF.SB.Cov %>% group_by(Plot.1) %>% 
summarise_each(funs(mean,sd,std.error))

#remove end points (neg end and pos end)
MF.SB.Cov3<-subset(MF.SB.Cov2 , MF.SB.Cov2$Plot.1 != "neg end")
MF.SB.Cov3<-subset(MF.SB.Cov3, MF.SB.Cov3$Plot.1 != "pos end")

#Convert values to numeric
MF.SB.Cov3$Plot<- as.numeric(MF.SB.Cov3$Plot.1)

#keep just end points
MF.SB.Cov3ends <- MF.SB.Cov2 %>%
  filter(Plot.1 %in% c("neg end", "pos end"))

#add point @ -10 and 10
MF.SB.Cov3ends$Plot.2 <- c(-10,10)



#Remove

#MF-PU
#Calculate Means and SE
MF.PU.Cov2 <- MF.PU.Cov %>% group_by(Plot.1) %>% 
summarise_each(funs(mean,sd,std.error))

#remove end points (neg end and pos end)
MF.PU.Cov3<-subset(MF.PU.Cov2 , MF.PU.Cov2$Plot.1 != "neg end")
MF.PU.Cov3<-subset(MF.PU.Cov3, MF.PU.Cov3$Plot.1 != "pos end")

#Convert values to numeric
MF.PU.Cov3$Plot<- as.numeric(MF.PU.Cov3$Plot.1)

#keep just end points
MF.PU.Cov3ends <- MF.PU.Cov2 %>%
  filter(Plot.1 %in% c("neg end", "pos end"))

#add point @ -10 and 10
MF.PU.Cov3ends$Plot.2 <- c(-10,10)


#MF-All
#Calculate Means and SE
MF.Cov2 <- MF.Cov %>% group_by(Plot.1) %>% 
summarise_each(funs(mean,sd,std.error))

#remove end points (neg end and pos end)
MF.Cov3<-subset(MF.Cov2 , MF.Cov2$Plot.1 != "neg end")
MF.Cov3<-subset(MF.Cov3, MF.Cov3$Plot.1 != "pos end")

#Convert values to numeric
MF.Cov3$Plot<- as.numeric(MF.Cov3$Plot.1)

#keep just end points
MF.Cov3ends <- MF.Cov2 %>%
  filter(Plot.1 %in% c("neg end", "pos end"))

#add point @ -10 and 10
MF.Cov3ends$Plot.2 <- c(-10,10)
```

#Aboveground Summary Stats to WD if desired
#Save in Working Directory
#write.csv(SGCov.SumStat,"", row.names = FALSE)
#write.csv(MFCov.SumStat,"", row.names = FALSE)

#Sigmoidal Regression Equation- Seagrass Cover
```{r}
#Prep Data
#remove end points (neg end and pos end)
#SG Cover
SG.Cov1a<-subset(SG.Cov1, SG.Cov1$Plot.1 != "neg end")
SG.Cov1a<-subset(SG.Cov1a, SG.Cov1a$Plot.1 != "pos end")

#Convert values to numeric
SG.Cov1a$Plot <- as.numeric(SG.Cov1a$Plot.1)

#Check shape of rawdata
plot(SG.Cov1a$SeagrassCov ~SG.Cov1a$Plot)
#looks like both a sigmoidal fit, both here and with means
plot(SG.Cov3$mean~SG.Cov3$Plot) #even better with means

#Build Dataframe
df <- data.frame('y' = SG.Cov1a$SeagrassCov, 'x' =SG.Cov1a$Plot)
#Plot
plot(df$y ~ df$x)
#Export to JMP
write.csv(df,"~/OneDrive - Old Dominion University/Ongoing Research/SG-Carbon.Ecotone/R.Data/SG.AG.df.csv", row.names = FALSE)
#Values from JMP
#R2 = 0.84
#AICc = 220.99
#Logistic 3P selected
#Equation from JMP
#Asymptote 
#c= 60.209
#Growth Rate
#a = -9.608
#Inflection Point
#b= -0.0108

# Generic Function <- 
#((c/(1+exp(-(a)*(x-(b))))))

fun2.AG.SG.Sig <- function(x) {
  (60.209/(1+exp(-(-9.608)*(x-(-0.0108)))))
  }

#plot curve to see what it looks like
curve(fun2.AG.SG.Sig, -8,8, ylab = "cover")
#Returns first derivative
D(expression((60.209/(1+exp(-(-9.608)*(x-(-0.0108)))))), 'x')

#Function of first derivative
AG.SG.D1 <-function(x){60.209 * (exp(-(-9.608) * (x - (-0.0108))) * (-9.608))/(1 + exp(-(-9.608) * (x - (-0.0108))))^2}

#Plots first derivative
curve(AG.SG.D1, -8, 8) 
#produces 1st derivative minimum (in this case)/aka inflection point of original equation
optimize(AG.SG.D1, interval = c(-8,8)) 
#$minimum
#[1] -0.01080665 <- This is the inflection point for Seagrass Cover

#Y value for inflection point using minimum
AG.SG.D1_Y <- (60.209/(1+exp(-(-9.608)*(-0.01080-(-0.0108)))))
print(AG.SG.D1_Y) #
#30.1045 <-----Y Value of Inflection Point

#Calculation of 2nd Derivative
D(expression((60.209 * (exp(-(-9.608) * (x - (-0.0108))) * (-9.608))/(1 + exp(-(-9.608) * 
    (x - (-0.0108))))^2)), 'x')
  
#2nd Derivative
AG.SG.D2 <- function(x) {-(60.209 * (exp(-(-9.608) * (x - (-0.0108))) * (-9.608) * (-9.608))/(1 + 
    exp(-(-9.608) * (x - (-0.0108))))^2 - 60.209 * (exp(-(-9.608) * 
    (x - (-0.0108))) * (-9.608)) * (2 * (exp(-(-9.608) * (x - 
    (-0.0108))) * (-9.608) * (1 + exp(-(-9.608) * (x - (-0.0108))))))/((1 + 
    exp(-(-9.608) * (x - (-0.0108))))^2)^2)
}
#Plot of 2nd Derivative
curve(AG.SG.D2, -8,8)

optimize(AG.SG.D2, interval = c(-8,8), maximum = TRUE) # Max of 2nd derivative
optimize(AG.SG.D2, interval = c(-8,8)) # Minimum of 2nd derivative

#SG Cover AoT
#-0.1478839 to 0.1262674

```



#Plot Data
```{r}
SeagrassAbvgd<- ggplot() +
  xlab("Plot (m)") + #x-label
  ylab("Seagrass Cover (%)")+ #y-label
  ylim(0,100) + #y-axis values
  xlim(-12,12)+
  scale_x_continuous(breaks=c(-8, -6, -4, -2, 0, 2, 4, 6, 8))+
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line = element_line(colour = "black"),
        legend.position = "none") +#Removes gray gridlines 
  geom_rect(data=SG.Cov3, mapping=aes(xmin=-0.1478839, xmax=0.1262674, ymin=0, ymax=100),fill = "blue", alpha=0.05)+ # box
  geom_point(data = SG.Cov3, aes(x=Plot, y=mean), color = "blue", size = 2)+
  geom_errorbar(data = SG.Cov3, aes(x= Plot, ymin= mean -std.error,ymax= mean + std.error), width = 0.5, color = "blue")+ #error bars
  stat_function(xlim =c(-8,8), fun = fun2.AG.SG.Sig, colour = "blue", linetype = "dashed")+#function curve for SG.AG.Cover
  geom_point(data = SG.COV3ends, aes(x=Plot.2, y = mean), color = "blue", shape = 17, size =4)+ #end points
   geom_errorbar(data = SG.COV3ends,aes(x= Plot.2, ymin= mean -std.error,ymax= mean + std.error), width = 0.5, color = "blue")+ #error bars
geom_vline(xintercept=-0.01080665, linetype='dashed', color='black', size=1)+
geom_vline(xintercept=-9, color='black', size=1)+
geom_vline(xintercept=9, color='black', size=1)

print(SeagrassAbvgd)
```

#Sigmoidal Regression Equation- MF.SB Cover
```{r}
#Prep Data
#remove end points (neg end and pos end)
#MF.SB Cover
MF.SB.Cov1a<-subset(MF.SB.Cov1, MF.SB.Cov1$Plot.1 != "neg end")
MF.SB.Cov1a<-subset(MF.SB.Cov1a, MF.SB.Cov1a$Plot.1 != "pos end")

#Convert values to numeric
MF.SB.Cov1a$Plot <- as.numeric(MF.SB.Cov1a$Plot.1)

#Check shape of rawdata
plot(MF.SB.Cov1a$MangCanCov ~MF.SB.Cov1a$Plot)
#looks like both a sound sigmoidal fit, both here and with means
plot(MF.SB.Cov3$mean~MF.SB.Cov3$Plot) #even better with means

#Build Dataframe
df <- data.frame('y' = MF.SB.Cov1a$MangCanCov, 'x' =MF.SB.Cov1a$Plot)
#Plot
plot(df$y ~ df$x)
#Export to JMP
write.csv(df,"~/OneDrive - Old Dominion University/Ongoing Research/SG-Carbon.Ecotone/R.Data/MF.SB.AG.df.csv", row.names = FALSE)
#Values from JMP
#R2 = 0.909
#AICc = 210.75
#Logistic 3P selected
#Equation from JMP
#Asymptote 
#c= 100.101
#Growth Rate
#a = -0.657
#Inflection Point
#b= 1.085

# Generic Function <- 
#((c/(1+exp(-(a)*(x-(b))))))

fun2.AG.MF.SB.Sig <- function(x) {
  (100.101/(1+exp(-(-0.657)*(x-(1.085)))))
  }

#plot curve to see what it looks like
curve(fun2.AG.MF.SB.Sig, -8,8, ylab = "cover")
#Returns first derivative
D(expression((100.101/(1+exp(-(-0.657)*(x-(1.085)))))), 'x')

#Function of first derivative
AG.MF.SB.D1 <-function(x){100.101 * (exp(-(-0.657) * (x - (1.085))) * (-0.657))/(1 + exp(-(-0.657) * 
    (x - (1.085))))^2}

#Plots first derivative
curve(AG.MF.SB.D1, -8, 8) 
#produces 1st derivative minimum (in this case)/aka inflection point of original equation
optimize(AG.MF.SB.D1, interval = c(-8,8)) 
#minimum
# 1.085008 <- This is the inflection point for Mangrove-SB Cover

#Y value for inflection point using minimum
AG.MF.SB.D1_Y <- (100.101/(1+exp(-(-0.657)*(1.085-(1.085)))))
print(AG.MF.SB.D1_Y) #
#50.0505 <-----Y Value of Inflection Point

#Calculation of 2nd Derivative
D(expression((100.101 * (exp(-(-0.657) * (x - (1.085))) * (-0.657))/(1 + exp(-(-0.657) * 
    (x - (1.085))))^2)), 'x')
  

#2nd Derivative
AG.MF.SB.D2 <- function(x) {-(100.101 * (exp(-(-0.657) * (x - (1.085))) * (-0.657) * (-0.657))/(1 + 
    exp(-(-0.657) * (x - (1.085))))^2 - 100.101 * (exp(-(-0.657) * 
    (x - (1.085))) * (-0.657)) * (2 * (exp(-(-0.657) * (x - (1.085))) * 
    (-0.657) * (1 + exp(-(-0.657) * (x - (1.085))))))/((1 + exp(-(-0.657) * 
    (x - (1.085))))^2)^2)
}
#Plot of 2nd Derivative
curve(AG.MF.SB.D2, -8,8)

optimize(AG.MF.SB.D2, interval = c(-8,8), maximum = TRUE) # Max of 2nd derivative
optimize(AG.MF.SB.D2, interval = c(-8,8)) # Minimum of 2nd derivative

#Mangrove.SB Cover AoT
# -0.9195097 to 3.08952

```

#Plot Data- AG. MF-SB
```{r}
Mangrove.SB.AG<- ggplot() +
  xlab("Plot (m)") + #x-label
  ylab("Mangrove Cover (%)")+ #y-label
  ylim(0,100) + #y-axis values
  xlim(-12,12)+
  scale_x_continuous(breaks=c(-8, -6, -4, -2, 0, 2, 4, 6, 8))+
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line = element_line(colour = "black"))+
        #legend.position = "none") +#Removes gray gridlines 
  geom_rect(data=MF.SB.Cov3, mapping=aes(xmin=-0.9195097, xmax=3.08952, ymin=0, ymax=100), fill = "green3", alpha=0.05)+ # box
  geom_point(data = MF.SB.Cov3, aes(x=Plot, y=mean), color = "green4", size = 2)+ # means
  geom_errorbar(data= MF.SB.Cov3, aes(x= Plot, ymin= mean -std.error,ymax= mean + std.error), width = 0.5, color = "green4")+ # error bars
    stat_function(xlim =c(-8,8), fun = fun2.AG.MF.SB.Sig, colour = "green4", linetype = "dashed") +#function curve for MF.SB.AG.Cover
geom_vline(xintercept=1.085008, linetype='dashed', color='black', size=1)+
geom_point(data = MF.SB.Cov3ends, aes(x=Plot.2, y = mean), color = "green4", shape = 17, size =4)+#end points
geom_errorbar(data = MF.SB.Cov3ends, aes(x= Plot.2, ymin= mean -std.error,ymax= mean + std.error), width = 0.5, color = "green4")+ 
geom_vline(xintercept=-9, color='black', size=1)+
geom_vline(xintercept=9, color='black', size=1)

print(Mangrove.SB.AG)
```
#Sigmoidal Regression Equation- MF.PU Cover
```{r}
#Prep Data
#remove end points (neg end and pos end)
#MF.PU Cover
MF.PU.Cov1a<-subset(MF.PU.Cov1, MF.PU.Cov1$Plot.1 != "neg end")
MF.PU.Cov1a<-subset(MF.PU.Cov1a, MF.PU.Cov1a$Plot.1 != "pos end")

#Convert values to numeric
MF.PU.Cov1a$Plot <- as.numeric(MF.PU.Cov1a$Plot.1)

#Check shape of rawdata
plot(MF.PU.Cov1a$MangCanCov ~MF.PU.Cov1a$Plot)
#looks like both a sound sigmoidal fit, both here and with means
plot(MF.PU.Cov3$mean~MF.PU.Cov3$Plot) #even better with means

#Build Dataframe
df <- data.frame('y' = MF.PU.Cov1a$MangCanCov, 'x' =MF.PU.Cov1a$Plot)
#Plot
plot(df$y ~ df$x)
#Export to JMP
write.csv(df,"~/OneDrive - Old Dominion University/Ongoing Research/SG-Carbon.Ecotone/R.Data/MF.PU.AG.df.csv", row.names = FALSE)
#Values from JMP
#R2 = 0.953
#AICc = 201.362
#Logistic 3P selected
#Equation from JMP
#Asymptote 
#c= 92.852
#Growth Rate
#a = -1.332
#Inflection Point
#b= 0.666

# Generic Function <- 
#((c/(1+exp(-(a)*(x-(b))))))

fun2.AG.MF.PU.Sig <- function(x) {
  (92.852/(1+exp(-(-1.332)*(x-(0.666)))))
  }

#plot curve to see what it looks like
curve(fun2.AG.MF.PU.Sig, -8,8, ylab = "cover")
#Returns first derivative
D(expression((92.852/(1+exp(-(-1.332)*(x-(0.666)))))), 'x')

#Function of first derivative
AG.MF.PU.D1 <-function(x){92.852 * (exp(-(-1.332) * (x - (0.666))) * (-1.332))/(1 + exp(-(-1.332) * 
    (x - (0.666))))^2}

#Plots first derivative
curve(AG.MF.PU.D1, -8, 8) 
#produces 1st derivative minimum (in this case)/aka inflection point of original equation
optimize(AG.MF.PU.D1, interval = c(-8,8)) 
#minimum
# 0.666 <- This is the inflection point for Mangrove-PU Cover

#Y value for inflection point using minimum
AG.MF.PU.D1_Y <- (92.852/(1+exp(-(-1.332)*(0.666-(0.666)))))
print(AG.MF.PU.D1_Y) #
#46.426 <-----Y Value of Inflection Point

#Calculation of 2nd Derivative
D(expression((92.852 * (exp(-(-1.332) * (x - (0.666))) * (-1.332))/(1 + exp(-(-1.332) * 
    (x - (0.666))))^2)), 'x')
  

#2nd Derivative
AG.MF.PU.D2 <- function(x) {-(92.852 * (exp(-(-1.332) * (x - (0.666))) * (-1.332) * (-1.332))/(1 + 
    exp(-(-1.332) * (x - (0.666))))^2 - 92.852 * (exp(-(-1.332) * 
    (x - (0.666))) * (-1.332)) * (2 * (exp(-(-1.332) * (x - (0.666))) * 
    (-1.332) * (1 + exp(-(-1.332) * (x - (0.666))))))/((1 + exp(-(-1.332) * 
    (x - (0.666))))^2)^2)
}
#Plot of 2nd Derivative
curve(AG.MF.PU.D2, -8,8)

optimize(AG.MF.PU.D2, interval = c(-8,8), maximum = TRUE) # Max of 2nd derivative
optimize(AG.MF.PU.D2, interval = c(-8,8)) # Minimum of 2nd derivative

#Mangrove.PU Cover AoT
# -0.3227063 to 1.654715

```


#Plot Data- MF-PU
```{r}
Mangrove.PU.AG<- ggplot(MF.PU.Cov3) +
  xlab("Plot (m)") + #x-label
  ylab("Mangrove Cover (%)")+ #y-label
  ylim(0,100) + #y-axis values
  xlim(-8.5,8.5)+
  scale_x_continuous(breaks=c(-8, -6, -4, -2, 0, 2, 4, 6, 8))+
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line = element_line(colour = "black"), legend.position = "none") +#Removes gray gridlines 
  geom_rect(data=MF.SB.Cov3, mapping=aes(xmin=-0.3227063, xmax=1.654715, ymin=0, ymax=100), fill = "green3", alpha=0.05)+ # box
  geom_point(data = MF.PU.Cov3, aes(x=Plot, y=mean), color = "green4", size = 2)+
  geom_errorbar(aes(x= Plot, ymin= mean -std.error,ymax= mean + std.error), width = 0.5, color = "green4")+
   stat_function(xlim =c(-8,8), fun = fun2.AG.MF.PU.Sig, colour = "green4", linetype = "dashed")+ #function curve for MF.PU.AG.Cover
geom_vline(xintercept=0.666, linetype='dashed', color='black', size=1)+
  geom_point(data = MF.PU.Cov3ends, aes(x=Plot.2, y = mean), color = "green4", shape = 17, size =4)+#end points
geom_errorbar(data = MF.PU.Cov3ends, aes(x= Plot.2, ymin= mean -std.error,ymax= mean + std.error), width = 0.5, color = "green4")+ 
geom_vline(xintercept=-9, color='black', size=1)+
geom_vline(xintercept=9, color='black', size=1)

print(Mangrove.PU.AG)
```
#Sigmoidal Regression Equation- Mangrove Cover
```{r}
#Prep Data
#remove end points (neg end and pos end)
#MF Cover
MF.Cov1a<-subset(MF.Cov1, MF.Cov1$Plot.1 != "neg end")
MF.Cov1a<-subset(MF.Cov1a, MF.Cov1a$Plot.1 != "pos end")

#Convert values to numeric
MF.Cov1a$Plot <- as.numeric(MF.Cov1a$Plot.1)

#Check shape of rawdata
plot(MF.Cov1a$MangCanCov ~MF.Cov1a$Plot)
#looks like both a sound sigmoidal fit, both here and with means
plot(MF.Cov3$mean~MF.Cov3$Plot) #even better with means

#Build Dataframe
df <- data.frame('y' = MF.Cov1a$MangCanCov, 'x' =MF.Cov1a$Plot)
#Plot
plot(df$y ~ df$x)
#Export to JMP
write.csv(df,"~/OneDrive - Old Dominion University/Ongoing Research/SG-Carbon.Ecotone/R.Data/MF.AG.df.csv", row.names = FALSE)
#Values from JMP
#R2 = 0.918
#AICc = 414.862
#Logistic 3P selected
#Equation from JMP
#Asymptote 
#c= 95.449
#Growth Rate
#a = -0.994
#Inflection Point
#b= 0.850

# Generic Function <- 
#((c/(1+exp(-(a)*(x-(b))))))

fun2.AG.MF.Sig <- function(x) {
  (95.449/(1+exp(-(-0.994)*(x-(0.850)))))
  }

#plot curve to see what it looks like
curve(fun2.AG.MF.Sig, -8,8, ylab = "cover")
#Returns first derivative
D(expression((95.449/(1+exp(-(-0.994)*(x-(0.850)))))), 'x')

#Function of first derivative
AG.MF.D1 <-function(x){95.449 * (exp(-(-0.994) * (x - (0.85))) * (-0.994))/(1 + exp(-(-0.994) * 
    (x - (0.85))))^2}

#Plots first derivative
curve(AG.MF.D1, -8, 8) 
#produces 1st derivative minimum (in this case)/aka inflection point of original equation
optimize(AG.MF.D1, interval = c(-8,8)) 
#minimum
# 0.8500125 <- This is the inflection point for Mangrove-PU Cover

#Y value for inflection point using minimum
AG.MF.D1_Y <- (95.449/(1+exp(-(-0.994)*(0.850-(0.850)))))
print(AG.MF.D1_Y) #
#47.7245 <-----Y Value of Inflection Point

#Calculation of 2nd Derivative
D(expression((95.449 * (exp(-(-0.994) * (x - (0.85))) * (-0.994))/(1 + exp(-(-0.994) * 
    (x - (0.85))))^2)), 'x')
  

#2nd Derivative
AG.MF.D2 <- function(x) {-(95.449 * (exp(-(-0.994) * (x - (0.85))) * (-0.994) * (-0.994))/(1 + 
    exp(-(-0.994) * (x - (0.85))))^2 - 95.449 * (exp(-(-0.994) * 
    (x - (0.85))) * (-0.994)) * (2 * (exp(-(-0.994) * (x - (0.85))) * 
    (-0.994) * (1 + exp(-(-0.994) * (x - (0.85))))))/((1 + exp(-(-0.994) * 
    (x - (0.85))))^2)^2)}
#Plot of 2nd Derivative
curve(AG.MF.D2, -8,8)

optimize(AG.MF.D2, interval = c(-8,8), maximum = TRUE) # Max of 2nd derivative
optimize(AG.MF.D2, interval = c(-8,8)) # Minimum of 2nd derivative

#Mangrove.PU Cover AoT
# -0.4749081 to 2.174909

```
#Plot Data- MF
```{r}
Mangrove.AG<- ggplot(MF.Cov3) +
  xlab("Plot (m)") + #x-label
  ylab("Cover (%)")+ #y-label
  ylim(0,100) + #y-axis values
  xlim(-8.5,8.5)+
  scale_x_continuous(breaks=c(-8, -6, -4, -2, 0, 2, 4, 6, 8))+
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line = element_line(colour = "black"),
        legend.position = "none") +#Removes gray gridlines 
  geom_point(data = MF.Cov3, aes(x=Plot, y=mean), size = 2)+
  geom_errorbar(aes(x= Plot, ymin= mean -std.error,ymax= mean + std.error), width = 0.5)+
  stat_function(xlim =c(-8,8), fun = fun2.AG.MF.PU.Sig, colour = "black", linetype = "dashed") #function curve for MF.AG.Cover

print(Mangrove.AG)
```

Multiplot
```{r}
Abvgdall<-multiplot(SeagrassAbvgd, Mangrove.SB.AG, Mangrove.PU.AG, cols = 3)
```
print(Abvgdall)

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

